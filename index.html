<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pro-Visualizer v5.0 - Obsidian Director</title>
    <style>
      :root {
        --primary-color: #00ff41;
        --bg-color: #000000;
      }

      body {
        margin: 0;
        background-color: var(--bg-color);
        color: var(--primary-color);
        font-family: 'Courier New', Courier, monospace;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        overflow: hidden;
      }

      /* CRT Scanline Overlay */
      body::before {
        content: " ";
        display: block;
        position: absolute;
        top: 0; left: 0; bottom: 0; right: 0;
        background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.4) 50%), 
                    linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03));
        z-index: 10;
        background-size: 100% 3px, 3px 100%;
        pointer-events: none;
      }

      #file-info {
        position: absolute;
        top: 30px;
        text-align: center;
        z-index: 15;
        text-shadow: 0 0 15px var(--primary-color);
      }

      #drop-zone {
        position: absolute;
        width: 100%; height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 5;
      }

      canvas {
        width: 100%;
        height: 100%;
        filter: contrast(1.4) brightness(1.1);
      }

      .controls {
        position: absolute;
        bottom: 20px;
        z-index: 20;
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 15px;
        background: rgba(10, 10, 10, 0.95);
        padding: 15px 25px;
        border: 1px solid var(--primary-color);
        box-shadow: 0 0 20px rgba(0,0,0,1);
        max-width: 90vw;
      }

      .control-group {
        display: flex;
        flex-direction: column;
        gap: 5px;
        font-size: 10px;
      }

      button, select, input {
        background: transparent;
        color: var(--primary-color);
        border: 1px solid var(--primary-color);
        padding: 6px 10px;
        cursor: pointer;
        font-family: inherit;
        text-transform: uppercase;
      }

      input[type="range"] {
        cursor: ew-resize;
        padding: 0;
      }

      button:hover {
        background: var(--primary-color);
        color: #000;
      }

      #btn-record.recording {
        background: #ff0000;
        color: #fff;
        border-color: #ff0000;
        animation: pulse 1s infinite;
      }

      @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.5; }
        100% { opacity: 1; }
      }

      .hidden { display: none; }
    </style>
  </head>
  <body>
    <div id="file-info" class="hidden">
      <h3 id="file-name-display">---</h3>
      <small id="rec-status" style="color: #ff0000; display: none;">‚óè RECORDING</small>
    </div>

    <div id="drop-zone">
      <div id="instructions" style="text-align: center;">
        <h1>OSCILLOSCOPE v5.0</h1>
        <p style="opacity: 0.5;">DROP AUDIO FILE TO BEGIN</p>
      </div>
    </div>

    <canvas id="scope"></canvas>

    <div class="controls">
      <div class="control-group">
        <label>POWER</label>
        <button id="btn-play">Pause</button>
      </div>
      
      <div class="control-group">
        <label>MODE</label>
        <button id="btn-mode">Linear</button>
      </div>

      <div class="control-group">
        <label>THEME</label>
        <select id="theme-select">
          <option value="#00ff41">NEON GREEN</option>
          <option value="#00d4ff">ICE BLUE</option>
          <option value="#ff3300">PLASMA RED</option>
          <option value="#ffcc00">AMBER</option>
        </select>
      </div>

      <div class="control-group">
        <label>GAIN</label>
        <input type="range" id="input-gain" min="0.5" max="5" step="0.1" value="1">
      </div>

      <div class="control-group">
        <label>GLOW</label>
        <input type="range" id="input-glow" min="0" max="40" step="1" value="20">
      </div>

      <div class="control-group">
        <label>OUTPUT</label>
        <button id="btn-record">Start Record</button>
      </div>
    </div>

    <script>
      const canvas = document.getElementById('scope');
      const ctx = canvas.getContext('2d');
      const dropZone = document.getElementById('drop-zone');
      const playBtn = document.getElementById('btn-play');
      const modeBtn = document.getElementById('btn-mode');
      const themeSelect = document.getElementById('theme-select');
      const gainInput = document.getElementById('input-gain');
      const glowInput = document.getElementById('input-glow');
      const recordBtn = document.getElementById('btn-record');
      const fileNameDisplay = document.getElementById('file-name-display');
      const fileInfoDiv = document.getElementById('file-info');

      let audioCtx, analyser, source, dataArray, streamDest;
      let isCircular = false;
      let activeColor = '#00ff41';
      let mediaRecorder;
      let recordedChunks = [];

      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      window.addEventListener('resize', resize);
      resize();

      // Control Listeners
      themeSelect.addEventListener('change', (e) => {
        activeColor = e.target.value;
        document.documentElement.style.setProperty('--primary-color', activeColor);
      });

      playBtn.addEventListener('click', () => {
        if (!audioCtx) return;
        audioCtx.state === 'running' ? audioCtx.suspend() : audioCtx.resume();
        playBtn.innerText = audioCtx.state === 'running' ? 'Resume' : 'Pause';
      });

      modeBtn.addEventListener('click', () => {
        isCircular = !isCircular;
        modeBtn.innerText = isCircular ? 'Circular' : 'Linear';
      });

      // Recording Logic
      recordBtn.addEventListener('click', () => {
        if (mediaRecorder && mediaRecorder.state === "recording") {
          mediaRecorder.stop();
          recordBtn.innerText = "Start Record";
          recordBtn.classList.remove('recording');
          document.getElementById('rec-status').style.display = 'none';
        } else {
          startRecording();
        }
      });

      function startRecording() {
        recordedChunks = [];
        // Capture canvas stream @ 30fps
        const canvasStream = canvas.captureStream(30);
        
        // Add audio if available
        if (streamDest) {
          const audioTracks = streamDest.stream.getAudioTracks();
          if (audioTracks.length > 0) canvasStream.addTrack(audioTracks[0]);
        }

        mediaRecorder = new MediaRecorder(canvasStream, { mimeType: 'video/webm;codecs=vp9' });
        
        mediaRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) recordedChunks.push(e.data);
        };

        mediaRecorder.onstop = () => {
          const blob = new Blob(recordedChunks, { type: 'video/webm' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `Visualizer_Capture_${Date.now()}.webm`;
          a.click();
        };

        mediaRecorder.start();
        recordBtn.innerText = "Stop & Save";
        recordBtn.classList.add('recording');
        document.getElementById('rec-status').style.display = 'inline';
      }

      // File Handling
      dropZone.addEventListener('dragover', (e) => e.preventDefault());
      dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        const file = e.dataTransfer.files[0];
        if (file?.type.startsWith('audio/')) {
          fileNameDisplay.innerText = file.name.toUpperCase();
          fileInfoDiv.classList.remove('hidden');
          document.getElementById('instructions').classList.add('hidden');
          handleFile(file);
        }
      });

      async function handleFile(file) {
        if (audioCtx) audioCtx.close();
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        // Setup internal destination for recording audio
        streamDest = audioCtx.createMediaStreamDestination();

        const arrayBuffer = await file.arrayBuffer();
        const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
        
        source = audioCtx.createBufferSource();
        source.buffer = audioBuffer;
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;

        source.connect(analyser);
        analyser.connect(audioCtx.destination);
        analyser.connect(streamDest); // Pipe audio to the recorder stream

        dataArray = new Uint8Array(analyser.frequencyBinCount);
        source.start();
        draw();
      }

      function draw() {
        requestAnimationFrame(draw);
        analyser.getByteTimeDomainData(dataArray);

        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Grid
        ctx.strokeStyle = activeColor;
        ctx.lineWidth = 0.5;
        ctx.globalAlpha = 0.05;
        for (let i = 0; i < canvas.width; i += 100) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); ctx.stroke(); }
        for (let i = 0; i < canvas.height; i += 100) { ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(canvas.width, i); ctx.stroke(); }

        const gain = parseFloat(gainInput.value);
        const glow = parseFloat(glowInput.value);

        // Render Waveform Passes
        ctx.lineJoin = 'round';
        
        // 1. Ghost Pass
        ctx.globalAlpha = 0.15;
        ctx.lineWidth = 6;
        ctx.shadowBlur = 0;
        renderWave(gain, false);

        // 2. Glow Pass
        ctx.globalAlpha = 0.5;
        ctx.lineWidth = 3;
        ctx.shadowBlur = glow;
        ctx.shadowColor = activeColor;
        renderWave(gain, true);

        // 3. Sharp Core
        ctx.globalAlpha = 1.0;
        ctx.lineWidth = 1.5;
        ctx.strokeStyle = '#fff';
        ctx.shadowBlur = 2;
        renderWave(gain, true);
        ctx.strokeStyle = activeColor; // reset
      }

      function renderWave(gain, useTrigger) {
        let offset = 0;
        if (useTrigger && !isCircular) {
          for (let i = 0; i < dataArray.length / 2; i++) {
            if (dataArray[i] < 128 && dataArray[i+1] >= 128) { offset = i; break; }
          }
        }
        isCircular ? drawCircular(gain) : drawLinear(offset, gain);
      }

      function drawLinear(offset, gain) {
        ctx.beginPath();
        const sliceWidth = canvas.width / (dataArray.length / 2);
        let x = 0;
        for (let i = offset; i < offset + (dataArray.length / 2); i++) {
          const v = ((dataArray[i] - 128) * gain + 128) / 128.0;
          const y = (v * canvas.height) / 2;
          i === offset ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
          x += sliceWidth;
        }
        ctx.stroke();
      }

      function drawCircular(gain) {
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = Math.min(centerX, centerY) * 0.4;
        ctx.beginPath();
        for (let i = 0; i < dataArray.length; i++) {
          const angle = (i / dataArray.length) * Math.PI * 2;
          const amp = ((dataArray[i] - 128) * gain + 128) / 128.0;
          const r = radius * (0.7 + (amp * 0.4));
          const x = centerX + r * Math.cos(angle);
          const y = centerY + r * Math.sin(angle);
          i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.stroke();
      }
    </script>
  </body>
</html>